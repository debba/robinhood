from __future__ import annotations
from abc import ABC, abstractmethod
from typing import List, Any, Union, Callable, Dict, Iterable, Tuple
from datetime import datetime
from dataclasses import dataclass
from filesystem import AbstractPath
from rclone_python.rclone import copy, delete
from platformdirs import site_cache_path
from filesystem import convert_to_bytes, FileSystemObject, FileSystem, FileType
from enums import ActionDirection, SyncStatus, ActionType
from events import SyncEvent, RobinHoodBackend
from fnmatch import fnmatch
import os.path


def _parse_rclone_progress(actions: Iterable[AbstractSyncAction], sync_direction: ActionDirection,
                           output: Dict) -> SyncProgress:
    '''
    Creates a suitable SyncProgress and Action progress objects from the dictionary generated by rclone_python
    :param actions: List of all actions treated during synchronisation
    :param sync_direction: either source-to-destination or destination-to-source
    :param output: rclone_python output coming in the form of a dictionary
    :return: A SyncProgress object with all the information nicely formatted
    '''

    # sometimes rclone puts ellipsis for long paths - either of these conditions is fine
    match_path = lambda t, a: a.endswith(t) or fnmatch(a, t.replace("\u2026", "*"))

    current_time = datetime.now()

    individual_tasks = []

    for task in output['prog_transferring']:
        current_action = None

        # The aim of this for-loop is to match the task in rclone with the internal represation of that task
        # stored in a SyncAction within the list of actions
        for x in actions:
            # the source path depends on the direction of the action.
            # Whether to compare with x.a and x.b depends on where we are transfering from
            if (sync_direction == ActionDirection.SRC2DST) and match_path(task[0],
                                                                          x.a.relative_path):  # (x.a.relative_path.endswith(task[0])):
                current_action = x
                break
            if (sync_direction == ActionDirection.DST2SRC) and match_path(task[0],
                                                                          x.b.relative_path):  # (x.b.relative_path.endswith(task[0])):
                current_action = x
                break

        # if the action could not be found, something off is happening. All actions performed by rclone should
        # be the ones the user approved. Alternatively, there's a bug in the way paths are matched above.
        if current_action is not None:
            local_progress = ActionProgress(filename=task[0],
                                            progress=task[1],
                                            transfer_speed=task[2],
                                            timestamp=current_time)

            current_action.update = local_progress

            individual_tasks.append(current_action)

    output['prog_transferring'] = individual_tasks

    return SyncProgress(timestamp=current_time, **output)


def _get_trigger_fn(eventhandler: Union[SyncEvent | None] = None) -> Callable[[str, SyncEvent], None]:
    def _trigger(mtd: str, e: SyncEvent) -> None:
        if isinstance(eventhandler, RobinHoodBackend):
            try:
                fn = getattr(eventhandler, mtd)
                fn(e)
            except AttributeError:
                ...  # event does not exist

    return _trigger


@dataclass(frozen=True)
class ActionProgress:
    filename: str = ""
    progress: float = 0
    transfer_speed: str = ""
    timestamp: datetime = datetime.now()


@dataclass(frozen=True)
class SyncProgress():
    prog_transferring: [List[Any] | None] = None
    progress: float = 0
    total_bits: float = 0
    sent_bits: float = 0
    unit_sent: str = ""
    unit_total: str = ""
    transfer_speed: float = 0
    transfer_speed_unit: str = ""
    eta: str = ""
    timestamp: datetime = datetime.now()

    @property
    def bytes_transferred(this):
        return convert_to_bytes(this.sent_bits, this.unit_sent)

    @property
    def bytes_total(this):
        return convert_to_bytes(this.total_bits, this.unit_total)


class SyncComparisonEvent(SyncEvent):

    def __init__(this, src_path=None, dest_path=None):
        super().__init__((src_path, dest_path))

    @property
    def source_path(this):
        return this.value[0]

    @property
    def destination_path(this):
        return this.value[1]


class SyncDirectionNotPermittedException(Exception):
    ...


class AbstractSyncAction(ABC):

    def __init__(this,
                 a: FileSystemObject,
                 b: FileSystemObject,
                 type: ActionType = ActionType.NOTHING,
                 direction: Union[ActionDirection | None] = None):

        this.a = a
        this.b = b
        this._type:ActionType = type
        this._direction:Union[ActionDirection|None] = direction
        this._status:SyncStatus = SyncStatus.NOT_STARTED
        this._update = None
        this.parent_action_view:Union[SynchingManager.SyncManagerView | None] = None
        this._nested_actions: Union[SynchingManager.SyncManagerView|None] = None
        this.filtered=False

        this._validate_action_direction()

    @property
    def status(this) -> SyncStatus:
        return this._status

    @property
    def type(this):
        return this._type

    @property
    def direction(this):
        return this._direction

    @status.setter
    def status(this, value: SyncStatus) -> None:
        this._status = value

    @property
    def get_one_path(this) -> FileSystemObject:
        return this.a if this.b is None else this.b

    @property
    def update(this):
        return this.get_update()

    @update.setter
    def update(this, value):
        this._update = value

    @property
    def parents(this) -> List[AbstractSyncAction]:
        parents = []
        curr = this

        while (curr:=curr.parent_action) is not None:
            parents.append(curr)

        return parents

    @property
    def parent_action(this) -> Union[AbstractSyncAction | None]:
        if this.parent_action_view is None:
            return None
        else:
            return next(iter(this.parent_action_view))

    @parent_action.setter
    def parent_action(this, parent: Union[SynchingManager.SyncManagerView | None]) -> None:
        if parent is None:
            this.parent_action_view = None
        else:
            match len(parent):
                case 1:
                    this.parent_action_view = parent
                case 0:
                    this.parent_action_view = None
                case _:
                    raise ValueError("The provided view includes more than one parent")

    @property
    def nested_actions(this) -> Iterable[AbstractSyncAction]:
        if this._nested_actions is not None:
            # Initially, I'd return iter(this._nested_actions).
            # Couldn't do it due to this error:
            # StopIteration interacts badly with generators and cannot be raised into a Future
            for itm in this._nested_actions:
                yield itm

    @property
    def has_nested_actions(this) -> bool:
        return this._nested_actions is not None and len(this._nested_actions)>=0

    @abstractmethod
    def apply_action(this, show_progress=False, eventhandler: [SyncEvent | None] = None) -> None:
        ...

    @abstractmethod
    def _repr_type(this) -> str:
        ...

    @abstractmethod
    def _check_success(this) -> None:
        ...

    def _validate_action_direction(this):
        if this.direction is not None:
            if (this.direction == ActionDirection.SRC2DST) and (not this.a.exists):
                raise SyncDirectionNotPermittedException(
                    "Destination file does not exist to support a source-to-destination operation")
            elif (this.direction == ActionDirection.DST2SRC) and (not this.b.exists):
                raise SyncDirectionNotPermittedException(
                    "Source file does not exist to support a destination-to-source operation")

        if this.direction == ActionDirection.BOTH and not this.type.supports_both:
            raise SyncDirectionNotPermittedException("The provided action type does not support bidirectional changes")


    def set_nested_actions(this, view: Union[SynchingManager.SyncManagerView | None]) -> None:
        this._nested_actions = view


    def get_nested_actions(this) -> Union[SynchingManager.SyncManagerView|None]:
        return this._nested_actions

    def swap_direction(this) -> None:
        new_dir = ActionDirection.SRC2DST if this.direction == ActionDirection.DST2SRC else ActionDirection.DST2SRC

        fs = this.a if new_dir == ActionDirection.SRC2DST else this.b

        if not fs.exists:
            raise SyncDirectionNotPermittedException(
                f"Action swapping not possible because {fs.absolute_path} does not exist")

        this._direction = new_dir


    def apply_both_sides(this) -> None:
        if not this.type.supports_both:
            raise SyncDirectionNotPermittedException(f"This action does not support bidirectional changes")

        if not this.a.exists:
            raise FileNotFoundError(f"The file {this.a.absolute_path} does not exist")

        if not this.b.exists:
            raise FileNotFoundError(f"The file {this.b.absolute_path} does not exist")

        this._direction = this.direction.BOTH

    def get_update(this) -> Union[SyncProgress | None]:
        return this._update

    def __str__(this) -> str:
        action_type = this._repr_type()

        if (this.type != ActionType.NOTHING):
            action_type = str(this.direction) + action_type

        return f"{this.a} {action_type} {this.b}"

    def __repr__(this) -> str:
        return str(this)


class NoSyncAction(AbstractSyncAction):

    def __init__(this, a: FileSystemObject, b: FileSystemObject):
        super().__init__(a, b, type=ActionType.NOTHING)

    def _repr_type(this) -> str:
        return "-"

    def apply_action(this, show_progress=False, eventhandler: [SyncEvent | None] = None) -> None:
        this.status = SyncStatus.SUCCESS

    def _check_success(this) -> None:
        ...

    def swap_direction(this) -> None:
        ...

    def apply_both_sides(this) -> None:
        ...

    def _validate_action_direction(this):
        ...


class CopySyncAction(AbstractSyncAction):
    def __init__(this, a: FileSystemObject, b: FileSystemObject, direction=ActionDirection.SRC2DST):
        type = ActionType.UPDATE if (a.exists and b.exists) else ActionType.COPY

        super().__init__(a, b, type=type, direction=direction)

    @property
    def is_updating(this):
        return this.type == ActionType.UPDATE

    def _repr_type(this) -> str:
        return "+" if this.is_updating else "*"

    def apply_action(this, show_progress=False, eventhandler: [SyncEvent | None] = None) -> None:
        if this.filtered:
            return

        _trigger = _get_trigger_fn(eventhandler)

        def _update_internal_status(d: Dict):
            update = _parse_rclone_progress([this], this.direction, d)
            _trigger("on_synching", SyncEvent(update))

        src_file = this.a

        x = this.a.absolute_path
        y = this.b.containing_directory

        if (this.direction == ActionDirection.DST2SRC):
            src_file = this.b
            x = this.b.absolute_path
            y = this.a.containing_directory

        if src_file.type == FileType.REGULAR:
            this._status = SyncStatus.IN_PROGRESS
            copy(x, y, show_progress=show_progress, listener=_update_internal_status,
                 args=['--use-mmap', '--no-traverse'])
            this._check_success()
        else:
            this.stats = SyncStatus.SUCCESS

    def _check_success(this) -> None:
        if (this.status == SyncStatus.SUCCESS) or  this.filtered:
            return

        x = this.a
        y = this.b

        x.update_information()
        y.update_information()

        if (this.direction == ActionDirection.DST2SRC):
            x, y = y, x

        this._status = SyncStatus.SUCCESS if y.exists and (x.size == y.size) else SyncStatus.FAILED


class DeleteSyncAction(AbstractSyncAction):
    def __init__(this,
                 a: FileSystemObject,
                 b: FileSystemObject,
                 direction: Union[ActionDirection | None] = None):

        super().__init__(a, b, type=ActionType.DELETE, direction=direction)

    def _repr_type(this) -> str:
        return "x"

    def _validate_action_direction(this):
        if this is not None:
            x = this.a.exists
            y = this.b.exists

            if (this.direction == ActionDirection.SRC2DST) and (not y):
                raise SyncDirectionNotPermittedException(
                    "Destination file does not exist to support a source-to-destination operation")
            elif (this.direction == ActionDirection.DST2SRC) and (not x):
                raise SyncDirectionNotPermittedException(
                    "Source file does not exist to support a destination-to-source operation")
            elif (this.direction == ActionDirection.BOTH) and (not x) and (not y):
                raise SyncDirectionNotPermittedException("Both files must exist to support bidirectional action")

    def apply_action(this, show_progress=False, eventhandler: [SyncEvent | None] = None) -> None:
        if this.filtered:
            return

        _trigger = _get_trigger_fn(eventhandler)

        if (this.direction == ActionDirection.DST2SRC) or (this.direction == ActionDirection.BOTH):
            if this.a.type == FileType.REGULAR:
                delete(this.a.absolute_path)
        if (this.direction == ActionDirection.SRC2DST) or (this.direction == ActionDirection.BOTH):
            if this.b.type == FileType.REGULAR:
                delete(this.b.absolute_path)

        this._check_success()

        _trigger("on_synching", SyncEvent(this))

    def _check_success(this) -> None:
        if (this.status == SyncStatus.SUCCESS) or  this.filtered:
            return

        x = this.a
        y = this.b

        if (x.type == FileType.DIR) or (y.type == FileType.DIR):
            this._status = SyncStatus.SUCCESS
            return

        x.update_information()
        y.update_information()

        if (this.direction == ActionDirection.DST2SRC):
            x, y = y, x

        success = not y.exists
        if this.direction == ActionDirection.BOTH:
            success = success and (not x.exists)

        this._status = SyncStatus.SUCCESS if success else SyncStatus.FAILED

    def swap_direction(this) -> None:
        new_dir = ActionDirection.SRC2DST if this.direction == ActionDirection.DST2SRC else ActionDirection.DST2SRC

        fs = this.a if new_dir == ActionDirection.DST2SRC else this.b

        if not fs.exists:
            raise SyncDirectionNotPermittedException(
                f"Action swapping not possible because {fs.absolute_path} does not exist")

        this._direction = new_dir


class SynchingManager():
    """
    This class manages the application of each action between source and destination directories
    """


    class SyncManagerView(Iterable[AbstractSyncAction]):

        def __init__(this, mng:SynchingManager, keys:Iterable[int]):
            curr_keys = mng._changes.keys()

            this._indices = set([k for k in keys if k in curr_keys])
            this._manager = mng

        def __iter__(this):
            removed_ids = []
            for i in this._indices:
                try:
                    yield this._manager._changes[i]
                except KeyError:
                    # this error occurs when a view item points to an action that has been removed from the manager
                    # let's take advantage of this by removing this specific not exisitng item
                    removed_ids.append(i)

            for id in removed_ids:
                this._indices.remove(id)

        def __len__(this):
            return len(this._indices)
        @classmethod
        def from_actions(cls, mng:SynchingManager, actions:List[AbstractSyncAction]) -> SynchingManager.SyncManagerView:
            indices = [k for k,v in mng if v in actions]

            return SynchingManager.SyncManagerView(mng, indices)



    def __init__(this, source: FileSystem, destination: FileSystem):
        this.source = source
        this.destination = destination

        this._idx = 0

        this._changes = {}

    def __iter__(this) -> Iterable[Tuple[int,AbstractSyncAction]]:
        return iter(this._changes.items())

    def __len__(this) -> int:
        return len(this._changes)

    def __getitem__(this, item: int) -> AbstractSyncAction:
        return this._changes[item]

    def __contains__(this, action: AbstractSyncAction) -> bool:
        return action in this._changes

    @property
    def changes(this) -> Iterable[AbstractSyncAction]:
        return iter(this._changes.values())

    def index_of(this, action: AbstractSyncAction) -> Union[int|None]:
        """
        Returns the position of the provided action within the manager

        :param action: the action to retrieve its position
        """

        for k,v in this._changes.items():
            if v == action:
                return k

        return None

    def clear(this) -> None:
        this._changes = []

    def remove_action(this, idx:int) -> None:
        del this._changes[idx]

    def add_action(this, action: AbstractSyncAction) -> int:
        src_path = this.source.root
        dst_path = this.destination.root

        # Check if the paths in the provided action are rooted properly in both source and dest directories
        if not AbstractPath.is_root_of(action.a.absolute_path,
                                       src_path):  # this._root_source.is_under_root(action.a.absolute_path):
            raise ValueError(f"The file '{action.a.relative_path} 'is not in '{src_path}'")

        if not AbstractPath.is_root_of(action.b.absolute_path,
                                       dst_path):  # this._root_destination.is_under_root(action.b.absolute_path):
            raise ValueError(f"The file '{action.b.relative_path} 'is not in '{dst_path}'")

        id = this._idx

        this._changes[id] = action
        this._idx+=1

        return id

    def cancel_action(this, action: AbstractSyncAction, in_place: bool = False) -> AbstractSyncAction:
        """
        Converts any action with a NoSyncAction
        :param action: the action to nullify
        :return: A new action with similar parameters as the one in input
        """

        if (isinstance(action, NoSyncAction)):
            return action

        new_action = NoSyncAction(action.a, action.b)

        new_action.parent_action = action.parent_action_view
        new_action.set_nested_actions(action.get_nested_actions())

        if in_place:
            this.replace(action, new_action)

        return new_action

    def convert_to_delete(this, action: AbstractSyncAction, in_place: bool = False) -> AbstractSyncAction:

        if isinstance(action, DeleteSyncAction):
            return action

        dir = action.direction if action.direction is not None else ActionDirection.SRC2DST
        opposite_dir = ActionDirection.SRC2DST if dir == ActionDirection.DST2SRC else ActionDirection.DST2SRC

        try:
            new_action = SynchingManager.make_action(action.a, action.b, type=ActionType.DELETE, direction=dir)
        except SyncDirectionNotPermittedException:
            # attempted one direction - if the other fails, the exception will be escalated
            new_action = SynchingManager.make_action(action.a, action.b, type=ActionType.DELETE, direction=opposite_dir)

        new_action.parent_action = action.parent_action_view
        new_action.set_nested_actions(action.get_nested_actions())

        if in_place:
            this.replace(action, new_action)

        return new_action

    def replace(this, action: AbstractSyncAction, replace_with: AbstractSyncAction) -> None:

        for k,v in this._changes.items():
            if v == action:
                replace_with.set_nested_actions(action.get_nested_actions())
                replace_with.parent_action = action.parent_action_view

                this._changes[k] = replace_with

                return


    def sort(this, **kwargs) -> None:
        if "key" in kwargs:
            _fn = kwargs['key']
            kwargs['key'] = lambda x: _fn(x[1])
        else:
            kwargs['key'] = lambda x: x[1]


        sorted_changes = sorted(this._changes.items(), **kwargs)
        this._changes = dict(sorted_changes)

    # TODO: actions on directories must be put at the end
    # TODO: to check the success of directories, add the concept of nested actions and check if them all are successfull
    def apply_changes(this, show_progress: bool = False, eventhandler: [SyncEvent | None] = None) -> None:
        for x in this.changes:
            if (x.status != SyncStatus.SUCCESS) and (not x.filtered):
                x.apply_action(show_progress, eventhandler)
                this.flush_action(x)

        this._flush_cache()

    def _flush_cache(this) -> None:
        """
        Flushes the file system cache into the disk (JSON file) after changes have been applied
        """
        this.source.flush_file_object_cache()
        this.destination.flush_file_object_cache()

    def flush_action(this, action: AbstractSyncAction) -> None:
        """
        Flush action changes (if successful) within the directory trees.
        For example, if an action creates a file in the destination, it needs to be updated with such information

        :param action: Action to flush in the file system cache
        """

        if action.status != SyncStatus.SUCCESS:
            return

        match action.type:
            case ActionType.COPY | ActionType.UPDATE:
                side = this.destination if action.direction == ActionDirection.SRC2DST else this.source
                fso = action.b if action.direction == ActionDirection.SRC2DST else action.a

                if fso.type == FileType.REGULAR:
                    side.set_file(fso.fullpath, fso)
            case ActionType.DELETE:
                if (action.direction == ActionDirection.SRC2DST) or (action.direction == ActionDirection.BOTH):
                    fso = action.b
                    if fso.type == FileType.REGULAR:
                        this.destination.set_file(fso.fullpath, None)

                if (action.direction == ActionDirection.DST2SRC) or (action.direction == ActionDirection.BOTH):
                    fso = action.a
                    if fso.type == FileType.REGULAR:
                        this.source.set_file(fso.fullpath, None)

    def get_nested_changes(this, action: AbstractSyncAction, *, levels=1) -> SynchingManager.SyncManagerView:

        if action.a.type != FileType.DIR:
            return []

        actions_idx = [k for k, itm in this._changes.items()
                                                    if ((action.a.fullpath.is_parent_of(itm.a.absolute_path)) or
                                                    (action.b.fullpath.is_parent_of(itm.b.absolute_path))) and
                                                    itm != action
                      ]

        _count_levels = lambda x: len(AbstractPath.split(x))
        _match_levels = lambda x, y, l: (_count_levels(y) - _count_levels(x)) <= l

        if (type(levels) == int) and (levels > 0):
            actions_idx = [x for x in actions_idx if _match_levels(action.a.absolute_path, this._changes[x].a.absolute_path, levels) or
                                                     _match_levels(action.b.absolute_path, this._changes[x].b.absolute_path, levels)]

        return SynchingManager.SyncManagerView(this, actions_idx)

    @classmethod
    def make_action(cls, source: FileSystemObject,
                    destination: FileSystemObject,
                    type: ActionType,
                    direction: ActionDirection) -> AbstractSyncAction:

        match type:
            case ActionType.NOTHING:
                return NoSyncAction(source, destination)
            case ActionType.DELETE:
                return DeleteSyncAction(source, destination, direction)
            case ActionType.COPY | ActionType.UPDATE:
                return CopySyncAction(source, destination, direction=direction)
            case _:
                raise NotImplementedError("Not yet mate!")



class BulkCopySynchingManager(SynchingManager):

    def __init__(this,
                 source: FileSystem,
                 destination: FileSystem,
                 direction: ActionDirection):

        super().__init__(source, destination)

        this._direction = direction
        this._actions_in_progress = []

    def add_action(this, action: AbstractSyncAction) -> None:

        if action.type not in [ActionType.COPY, ActionType.UPDATE]:
            raise ValueError("The provided action is not copying or updating a file")

        if (action.direction != this._direction):
            raise ValueError("The provided action is towards a different synching direction")

        super().add_action(action)

    def apply_changes(this, show_progress: bool = False, eventhandler: [SyncEvent | None] = None) -> None:
        '''
        Applies bulk copy/update actions to destionation directory
        :param show_progress: A boolean representing whether to show the progress bar or not (useful for batch processes)
        :param eventhandler: A class extending RobinHoodBackend (where events will be passed to)
        '''

        # Gets the function that facilitate the triggering of events in the eventhandler (if provided)
        _trigger = _get_trigger_fn(eventhandler)

        def _update_internal_status(d: Dict) -> None:
            '''
            This internal function is used as callback function for the rclone_python copy function
            The updates coming from there are formatted and passed to the right SyncAction object
            :param d: Dictionary of updates as provided by rclone
            '''

            # Creates an object to format the dictionary provided by rclone_python with the current transfer update
            sync_update = _parse_rclone_progress(this.changes, this._direction, d)

            for current_action in sync_update.prog_transferring:
                # Let's check if this action is a new one (this means that we are either at the very
                # beginning or an action finished (either successfully or not)

                if current_action not in this._actions_in_progress:
                    # As this is an action that just started, its status is updated
                    current_action.status = SyncStatus.IN_PROGRESS
                    # And gets inside the club of actions in progress
                    this._actions_in_progress.append(current_action)

            for x in this._actions_in_progress:
                # if some actions have a time before the current_time value, it means that it doesn't
                # appear in the stdout of rclone, ie it's done (no matter if it's successful or not)
                if (x.update.timestamp < sync_update.timestamp):
                    x._check_success()
                    # Notify that this action is concluded
                    _trigger("on_synching", SyncEvent(x))

                    # Flush changes into file system
                    this.flush_action(x)

            # Filter out all the terminated actions
            this._actions_in_progress = [x for x in this._actions_in_progress if x.status == SyncStatus.IN_PROGRESS]

            # Notify that these actions are still in progress and send them as a list
            _trigger("on_synching", SyncEvent(sync_update))

        tmp_dir = site_cache_path()
        tmp_fname = f"rh_sync_tmp_{datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}.txt"

        path = os.path.join(tmp_dir, tmp_fname)

        with open(path, "w") as handle:
            for x in this.changes:
                if not x.filtered:
                    fso = x.a if this._direction == ActionDirection.SRC2DST else x.b
                    if fso.type == FileType.REGULAR:
                        handle.write(f"{fso.relative_path}\n")

        a = this.source.root
        b = this.destination.root

        if this._direction == ActionDirection.DST2SRC:
            a, b = b, a

        copy(a,
             b,
             show_progress=show_progress,
             listener=_update_internal_status,
             args=['--files-from', path, '--no-check-dest', '--no-traverse'])

        # Better double-checking again when it's done if everything has been copied successfully
        for itm in this.changes:
            if (itm.status in [SyncStatus.IN_PROGRESS, SyncStatus.NOT_STARTED]) and (not itm.filtered):
                itm._check_success()
                _trigger("on_synching", SyncEvent(itm))
                this.flush_action(itm)

        this._flush_cache()
